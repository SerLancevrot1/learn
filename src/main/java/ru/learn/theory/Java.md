# JAVA

### Области памяти JVM
- Stack
- Heap
- Metaspace. Ранее PermGen. Хранит статику, такую как метаданные загруженных классов
- Eden, New Generation, Old Generation и другие – специфичные для сборщика мусора части кучи, поколения.

![img.png](../../../../resources/pictures/img.png)

![img_1.png](../../../../resources/pictures/img_1.png)

### Изменения

#### Java 9
- приватные дефолтные методы в интерфейсах
- внутри try с ресурсами можно объявлять ресурсы не в круглых скобках, а просто передавая названия
- `List<String> list = List.of("s1", "s2", "s3")`. Так же в Set и Map. Коллекции имутабельные.

#### Java 11
- var
- методы String. `isBlank()`, `repeat()`, `lines()`, `strip()`

#### Java 12
- метод String. `transform()` преобразование строк через лямбду
- `collect(Colletors.teeng())` применение нескольких коллекторов в стриме

#### Java 14
- красивый `switch` с использованием `->` вместо `:`

#### Java 15
- красивое объявление длинной строки с помощью строкового литерала `"""`
- красивое `NullPointerException`

#### Java 16
- добавили `record` (неизменяемый класс, финальные поля, переопределенный `equals()` и `hashCode()`)
- при использовании instanceOf не обязательно кастить поле. Вместо этого можно в самом instanceOf объявить переменную `o instanceOf String str`
- `collect(Colletors.toList())` -> `toList()`

#### Java 17 
- `sealed` классы. При объявлении класса разрешает наследоваться только определенным, указанным классам

#### Java 21
- еще более красивый и мощный `switch`. `case String s when s.length() > 4 ...` 

#### Java 22
- unnamed переменные. Вместо придумывания названий переменных которые не используем можно заменять их на `_`. `catch(NumberFormatException _)` 

### Функциональные интерфейсы
- UnaryOperator
- BinaryOperator
- Predicat
- Consumer
- Supplier

### Garbage collectors

- **throughput (пропускная способность)** - Это сколько полезной работы делает приложение за всё время. Если приложение тратит мало времени на сборщик мусора, throughput высокий. Пример: из 100 секунд работы 2 секунды ушли на GC → throughput ≈ 98%.
- **latency (задержки)** - Это насколько долго приложение «зависает» из‑за GC — паузы, которые видит пользователь. Пример: одна пауза 200 ms может испортить отклик даже при хорошем throughput.
- **В чём конфликт?** Часто уменьшение пауз (лучший latency) требует дополнительных фоновых операций или ресурсов, что может немного снизить throughput. И наоборот — максимальный throughput может давать редкие, но длинные паузы.
- Коротко: **throughput** — это «сколько работы сделано», **latency** — это «насколько приложение подвисало». Решение — сначала измерить, затем выбрать настройку/GC под цель (либо меньше пауз, либо больше пропускной способности).

**Инструменты**: Включите лог GC (например, -Xlog:gc*), посмотрите **VisualVM** или **Java Flight Recorder** и метрики отклика (p95/p99).

- **Serial GC** - однопоточный, простейший, подходит разве что для небольших приложений без высокой нагрузки. При значительных объемах памяти вызывает долгие паузы, т.к. останавливает мир на время сборки.
- **Parallel GC** - многопоточный “Throughput” сборщик, целью которого максимизировать пропускную способность приложения, допуская более долгие паузы. Хорошо работает на многоядерных системах, но паузы stop-the-world могут быть большими.
- **CMS (Concurrent)** - дает меньшую latency (маленькие отдельные паузы), выполняя часть сборки вне Stop The World. Плата за это – меньший throughput. Способ сборки примерно как в предыдущих, работает с поколениями. В Java 9 уже объявлен deprecated;
- **G1 GC (Garbage First, по умолчанию в JDK 11, 17)** – _поколенческий региональный сборщик_, стремящийся держать паузы короткими и более предсказуемыми. Он разбивает кучу на регионы и убирает мусор в порциях. G1 подходит для большинства серверных приложений, стабильно работает даже с десятками гигабайт heap, обычно ограничивая паузы ~< 200 мс. Его можно настраивать, например, задав целевую максимальную паузу -XX:MaxGCPauseMillis=200 (в мс) – JVM постарается не превышать ее, хотя при высокой нагрузке гарантировать не может.
- **Shenandoah GC (шенандоу)** в Oracle JDK появилось в 17 - похож на G1, но с полностью конкурентной компактизацией (почти все делает параллельно с работой приложения). Ориентирован на низкие паузы, но исторически имел некоторые компромиссы по пропускной способности.
- **Z GC** - современный сборщик с _минимальными паузами_ (порядка нескольких миллисекунд или меньше) даже на очень больших кучах (сто гигабайт и выше). Он добивается этого за счет полностью параллельной работы и специальных техник (colored pointers, load barriers). В JDK 17 ZGC вышел из эксперимента, а в JDK 21 появился Generational ZGC – поколенческий режим для повышения эффективности. ZGC _особенно хорош в ситуациях_, где нужна ультранизкая задержка от GC – например, торговые системы, стриминг, онлайн-игры, где даже 50мс пауза нежелательна. ZGC почти устраняет влияние сборщика на latency.

Критерии выбора: **потребление ресурсов, пропускная способность, задержки**

### WeakReference и SoftReference
Упоминается в контексте сборки мусора. 

**SoftReference** используется при кешировании внутри системы и будет удален сборщиком мусора в случае если осталось мало памяти, а на объект существуют только ссылки SoftReference. Это критично при кэшировании, так как наш сборщик мусора самостоятельно освободит нам память в критичной ситуации, но до этого момента не будет "трогать" эти объекты.

**WeakReference** - в случае если на объект ссылаются только через weak-ссылки, то объект будет удален сразу при обходе сборщиком мусора. 

### Профилирование 
https://proselyte.net/load-testing-and-jvm-profiling/#java-app-profiling
Когда нагрузочное тестирование выявило проблемы (например, медленный эндпоинт, высокое время отклика или ошибки), на сцену выходит профилирование. **Профилирование** – это динамический анализ программы, позволяющий замерить, сколько ресурсов потребляют разные части кода (время выполнения методов, объем памяти под объекты, частота вызовов функций и т.п.). Цель профилирования – помочь оптимизации программы, указав узкие места в коде или конфигурации.

Существует два основных подхода к профилированию:
- **Инструментальное профилирование (instrumenting)** – когда в код внедряются специальные инструкции для сбора данных (например, подсчет времени входа/выхода из метода). Это может делать либо сам разработчик (вручную, или с помощью AOP), либо профилировщик на этапе загрузки класса. Инструментирование дает точные измерения конкретных методов, но имеет существенный overhead и может влиять на временные характеристики программы. 
- **Сэмплирующее профилирование (sampling)** – когда профилировщик периодически (например, каждые 10 мс) опрашивает потоки приложения и собирает текущие стеки вызовов. На основе множества выборок строится статистическая картина нагрузки по методам. Этот подход менее нагружает приложение (т.к. не каждое событие логируется, а лишь периодически), но результаты могут быть неточными в деталях (особенно для очень кратковременных функций). Тем не менее sampling-профилировщики широко применяются для поиска CPU hot spots, т.к. дают хорошее приближение с минимальным влиянием.

В контексте Spring Boot приложений и JVM профилирование охватывает несколько областей: 
- **CPU профилирование (Execution Profiling)** – измерение, какие методы/классы потребляют основное время CPU. Помогает найти неэффективный код, тяжелые алгоритмы. Например, можно обнаружить, что 40% CPU уходит в метод обработки JSON или в расчет каких-то данных – сигнал задуматься об оптимизации или кешировании результата.
- **Профилирование памяти (Memory Profiling)** – отслеживание использования памяти: какие объекты занимают много места, как растет heap, сколько объектов создается и не освобождается (возможные утечки). Анализируя распределение объектов в heap dump, можно найти, например, что остаются висеть сессии или кэш не очищается, или неправильная коллекция используется, растущая безгранично.
- **Анализ GC** – хотя сборка мусора автоматизирована, профилирование позволяет понять, как часто происходят GC, сколько времени они занимают, сколько памяти освобождается. Это можно делать по логам GC либо через специальные события (Flight Recorder собирает события GC). Оптимизация может включать тюнинг параметров GC или выбор другого алгоритма.
- **Профилирование потоков (Thread Profiling)** – наблюдение за состоянием потоков: сколько их, чем заняты, нет ли взаимоблокировок. Например, профайлер может показать, что потоки долго стоят в ожидании на монитор (блокировка) или, скажем, все 200 потоков Tomcat заняты и ждут ответа от внешнего веб-сервиса – это ценная информация для оптимизации (может, нужно увеличить пул или ограничить внешние вызовы). Инструменты позволяют делать thread dump и даже визуализировать, сколько времени поток провел в каком состоянии (Running, Waiting, Blocked).

**Практическая рекомендация**: Для Spring Boot приложения (JDK 17+), если у вас нет особых требований, можно оставить G1 (по умолчанию). Если же вы замечаете, что даже короткие паузы GC влияют на сервис (например, в логах или метриках видны скачки задержки из-за Full GC), и у вас современный JDK, попробуйте ZGC. Обязательно нагрузочно протестируйте под реальной нагрузкой, т.к. профиль приложения влияет. Например, для сервисов с большим количеством короткоживущих объектов ZGC может показать себя отлично. Если же объекты живут долго и heap заполняется значительной долей “старья”, generational ZGC (JDK 21+) значительно лучше ранней версии.









