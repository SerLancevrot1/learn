# Message brokers

### Разница между Kafka и RabbitMq
- созданы для разных целей, не совсем верно сравнивать лучше/хуже. Kafka горизонтально масштабируемая, крутой механизм обработки большого количества сообщений. RabbitMq же более классический Pub/Sub. Kafka- для событийности или переноса данных. RabbitMq хорош для запросов внутри сервисов
- RabbitMq не хранит сообщения после того как отдаст их слушателям
- RabbitMq обладает маршрутизацией, может сам определять кому направить сообщение
- RabbitMq хуже масштабируется

## KAFKA

Порядок чтения и записи в/из партиции топика **случайны!**

### Гарантия доставки у Kafka
- **At-most-once (“как максимум однократная доставка”)** сообщение не может быть доставлено больше одного раза. При этом сообщение может быть потеряно.
- **At-least-once (“как минимум однократная доставка”)**. сообщение никогда не будет потеряно. При этом сообщение может быть доставлено более одного раза. Достигается ретраями и подтверждениями. DeadLetterQueue
- **Exactly-once (“строго однократная доставка”)**. Все сообщения доставляются строго единожды. Достигается логикой на коньсьюмере

Коньсьюмер считается **ИДЕМПОТЕНТНЫМ** тогда, когда в нем есть логика позволяющая работать с дубликатами так, как будто это всегда было одно сообщение. При гарантии доставки At-least-once в коньсьюмер могут прилетать дубли сообщений. Много способов для реализации идемпотентности

За счет чего достигаются гарантии? 
- внутренние механизмы кафки
- система ретраев



### Подходы к обработке сообщений

**Dead Letter Queue** 
- описание. Отправка сообщения в отдельную «плохую» очередь после N неудач. Позволяет позже вручную или автоматически обработать.
- плюсы. Изоляция ошибочных сообщений; не блокирует основной поток; сохранность данных для повторной обработки. Упрощает мониторинг и отладку (все проблемные события собраны).
- минусы. Усложнение системы (нужен процесс обработки DLQ). Возможна задержка в обработке «отложенных» сообщений; рост объёма DLQ требует контроля.

**Retry Queue**
- описание. Повторные попытки через задержку, часто с экспоненциальным бэкоффом, с помощью отдельной очереди(-ей).
- плюсы. Автоматическое восстановление при временных сбоях без ручного вмешательства. Гибкость настройки задержек и числа попыток.
- минусы. Сложнее конфигурация (несколько очередей, таймеры). Риск зацикливания: в конечном счёте всё равно нужен fallback (DLQ) для неисправимых ошибок.

**Outbox pattern**
- описание. Транзакционное сохранение исходящего события в лок. БД с последующей отправкой в брокер из Outbox таблицы.
- плюсы. Гарантия доставки сообщений от продюсера даже при сбое брокера (нет потери). Обеспечивает целостность данных между БД и сообщениями (решает dual-write проблему).
- минусы. Не решает проблем на стороне консюмера (требуется DLQ для обработки). Усложняет отправителя: нужна доп. таблица, фоновые таски, нагрузка на БД.

**Error Queue**
- описание. Отправка информации об ошибках в отдельный топик/очередь для мониторинга.
- плюсы. Простая реализация; прозрачность – команда сразу видит, что и когда сломалось.
- минусы. Обычно не хранит само сообщение, а только описание ошибки – затруднен повторный пуск. Фактически равнозначно потере сообщений (данные не обрабатываются, только логируются).

**Checkpoint/txn (exactly-once)**
- описание. Использование механизмов фреймворков стриминга для отката и повторного воспроизведения событий при ошибке.
- плюсы. Обработка ошибок «под капотом», без ручной работы; гарантированная целостность потока. Нет отдельной «мёртвой» очереди – система сама доводит до успеха или останавливается
- минусы. Доступно не во всех системах (Kafka Streams, Flink и пр.). Сложно в реализации, высокие накладные расходы; не подходит для побочных эффектов (e.g. реальных внешних действий).

**Fail-fast**
- описание. При любой неперехваченной ошибке остановить потребитель или весь конвейер до вмешательства человека.
- плюсы. Максимальная строгость – ни одно сообщение не игнорируется, порядок сохраняется.
- минусы. Сильно снижает доступность системы; требует постоянной готовности поддержки. Не подходит для потоков с высокой частотой ошибок или ненадёжных внешних систем.

### Чек‑лист повышения пропускной способности Kafka

Продьюсер
- **linger.ms** — увеличить время ожидания перед отправкой, чтобы формировать большие батчи (плюс: throughput; минус: задержка).
- **batch.size** — увеличить размер батча в байтах для более крупных пакетов (плюс: меньше сетевых вызовов; минус: память/латентность).
- **compression.type** — включить сжатие (snappy, lz4, zstd) для уменьшения трафика (плюс: сеть/IO; минус: CPU).
- **buffer.memory** — увеличить буфер памяти для очереди сообщений на отправку (плюс: устойчивость к всплескам; минус: память).
- **acks** — снизить уровень подтверждений (1 или 0) для увеличения скорости (плюс: throughput; минус: надежность).
- **retries / max.in.flight.requests** — балансировать количество повторов и одновременных запросов; при включённой идемпотентности согласовать параметры.
- **enable.idempotence** — включить для предотвращения дублей при retry (плюс: корректность; минус: может ограничить concurrency).
- **Партиционирование** — увеличить число партиций топика для большей параллельной записи (плюс: масштаб; минус: управление и метаданные).

Консьюмер
- **fetch.min.bytes** — увеличить минимальный объём для выборки, чтобы брокер ждал большего пакета (плюс: throughput; минус: латентность).
- **fetch.max.wait.ms** — увеличить время ожидания для формирования больших ответов от брокера (плюс: батчи; минус: задержка).
- **max.partition.fetch.bytes** — увеличить максимум данных на партицию за fetch (плюс: меньше запросов; минус: память).
- **max.poll.records** — брать больше сообщений за один poll (плюс: эффективность; минус: дольше обработка одного poll).
- **Параллельная обработка** — распределять обработку сообщений на рабочие потоки (плюс: CPU-утилитизация; минус: сложность оффсетов/порядка).
- **Коммит оффсетов** — реже коммитить (или коммитить асинхронно) для снижения накладных расходов (плюс: throughput; минус: риск повторной обработки).
- **Оптимизировать десериализацию/логическую обработку** (плюс: меньше CPU/задержек; минус: рефакторинг).

Топики и кластер
- **Число партиций** — увеличить для параллелизма, но не чрезмерно (плюс: масштаб; минус: нагрузка на контроллер/метаданные).
- **Репликация/min.insync.replicas** — уменьшение уровня синхронной репликации повышает throughput, но снижает надежность.
- **Настройки брокеров** (лог сегменты, replica.fetch.max.bytes) — оптимизировать под нагрузку диска/сети.

Инфраструктура и ресурсы
- **Проверить сетевой канал** — узкие места сети ограничат эффективность (плюс изменения: пропускная способность).
- **Диски брокеров** (SSD, настройки fsync) — медленные диски тормозят запись/репликацию.
- **CPU на клиенте** — компрессия и сериализация требуют CPU; масштабировать при необходимости.

Тестирование и мониторинг
- **Нагрузочное тестирование** — измерять изменения под реальной/синтетической нагрузкой.
- **Метрики** — отслеживать latency, request/second, batch sizes, CPU, network IO, GC.
- **Пошаговые изменения** — менять одну настройку за раз и измерять эффект.
- **Документировать** rollback-план для критичных изменений.
