# Базы данных

### Реляционные 

### Нереляционные/NoSql
Бывают:
- Ключ-значение
- Графовые
- Столбцовые
- Документные

Хороший выбор если:
- Нужна крайне низкая задержка (латентность)
- Данные не структурированы или не имеют связей
- Нужно всего лишь сериализовать/десериализовать данные (XML, JSON, YAML)
- Нужно хранить огромные объемы данных
- 

### Индексы PostgreSQL
- **B-tree** - это самый распространенный тип индекса в PostgreSQL. Он поддерживает все стандартные операции сравнения (>, <, >=, <=, =, <>) и может использоваться с большинством типов данных. B-tree индексы могут быть использованы для сортировки, ограничений уникальности и поиска по диапазону значений.
- **Hash** - предназначены для обеспечения быстрого доступа к данным по **равенству**. Они менее эффективны, чем B-tree индексы, и **не поддерживают сортировку или поиск по диапазону значений**. Из-за своих ограничений, Hash-индексы редко используются на практике.
- **GiST (Generalized Search Tree)** - являются обобщенными и многоцелевыми, предназначены для работы с сложными типами данных, такими как **геометрические объекты, текст и массивы**. Они позволяют быстро выполнять поиск по **пространственным, текстовым и иерархическим данным**.
- **SP-GiST (Space-Partitioned Generalized Search Tree)** - предназначены для работы с непересекающимися и неравномерно распределенными данными. Они эффективны для поиска в **геометрических и IP-адресных данных**.
- **GIN (Generalized Inverted Index)** - применяются для **полнотекстового поиска** и поиска по **массивам, JSON и триграммам**. Они обеспечивают высокую производительность при поиске в больших объемах данных.
- **BRIN (Block Range INdex)** - используются для компактного представления больших объемов данных, особенно когда значения в таблице имеют определенный порядок. Они эффективны для хранения и обработки временных рядов и географических данных.
- 


### N + 1
- **FetchType.LAZY** `@ManyToOne(fetch = FetchType.LAZY)`
- **EntityGraph** вы можете заранее указать, какие объекты нужно загрузить вместе с основным объектом.
- **JOIN FETCH** Этот оператор объединяет основную таблицу и связанные таблицы в одном SQL-запросе, что позволяет загрузить данные сразу за один раз. Таким образом, JOIN FETCH позволяет эффективно загружать связанные объекты одновременно с основными объектами, уменьшая количество обращений к базе данных.


### Блокировки
- Оптимистические - использует версии. Работает по принципу CAS (Compare And Swap): сравнил и, если версия больше, заменил.
- Пессимистические - классическая полная блокировка

### ACID

В информатике акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и
предсказуемую её работу.

#### Atomicity — Атомарность

Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не
выполнено ни одной.

#### Consistency — Согласованность

Каждая успешная транзакция по определению фиксирует только допустимые результаты.

#### Isolation — Изолированность

Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Изолированность — требование дорогое,
поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию

#### Durability — Долговечность

Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут
отменены из-за какого-либо сбоя.

### Проблемы параллельного доступа с использованием транзакций

**Потерянное обновление (англ. lost update)** — при одновременном изменении одного блока данных разными транзакциями одно из изменений
теряется;

| Транзакция 1                           | Транзакция 2                           |
|----------------------------------------|----------------------------------------|
| `UPDATE tbl1 SET f2=f2+20 WHERE f1=1;` | `UPDATE tbl1 SET f2=f2+25 WHERE f1=1;` |

**Грязное чтение (англ. dirty read)** — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (
откатится);

| Транзакция 1                          | Транзакция 2                      |
|---------------------------------------|-----------------------------------|
| `UPDATE tbl1 SET f2=f2+1 WHERE f1=1;` |                                   |
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |
| `ROLLBACK WORK;`                      |                                   |

**Неповторяющееся чтение (англ. non-repeatable read)** — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются
изменёнными;

| Транзакция 1                          | Транзакция 2                      |
|---------------------------------------|-----------------------------------|
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |
| `UPDATE tbl1 SET f2=f2+1 WHERE f1=1;` |                                   |
| `COMMIT;`                             |                                   |
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |

**Фантомное чтение (англ. phantom reads)** — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем
же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки, или изменяет столбцы некоторых строк,
используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой
транзакции дают разные множества строк.

| Транзакция 1                               | Транзакция 2                |
|--------------------------------------------|-----------------------------|
|                                            | `SELECT SUM(f2) FROM tbl1;` |
| `INSERT INTO tbl1 (f1,f2) VALUES (15,20);` |                             |
| `COMMIT;`                                  |                             |
|                                            | `SELECT SUM(f2) FROM tbl1;` |

### Уровень изолированности транзакций

**Уровень изолированности транзакций** — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.

Стандарт SQL-92 определяет шкалу из четырёх уровней изоляции: Read uncommitted, Read committed, Repeatable read, Serializable.
- Read uncommitted - позволяет читать данные которые не были закомиченны. Нет гарантии что данные не изменятся
- Read committed - позволяет читать только закомиченные данные
- Repeatable read - позволяет чтение и запись пока другая транзакция активна. Но если транзакция понимает что данные изменились, но она не будет коммитится
- Serializable - полностью блокирует сроки пока транзакция не закончится




### Нормальные формы

**Нормальная форма** — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных
функциональных зависимостей между атрибутами (полями таблиц).

#### Первая нормальная форма

Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не
должно быть повторений строк в таблице.

Например, есть таблица «Автомобили»:

| Фирма  | Модели      |
|--------|-------------|
| BMW    | M5, X5M, M1 |
| Nissan | GT-R        |

Нарушение нормализации 1НФ происходит в моделях BMW, т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, т.е. он не является
атомарным. Преобразуем таблицу к 1НФ:

| Фирма  | Модели |
|--------|--------|
| BMW    | M5     |
| BMW    | X5M    |
| BMW    | M1     |
| Nissan | GT-R   |

#### Вторая нормальная форма

Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут зависит от Первичного Ключа(ПК).

| Модель | Фирма  | Цена  | Скидка |
|--------|--------|-------|--------|
| M5     | BMW    | 123   | 5%     |
| X5M    | BMW    | 3213  | 5%     |
| M1     | BMW    | 12312 | 5%     |
| GT-R   | Nissan | 12323 | 10%    |

Таблица находится в первой нормальной форме, но не во второй. Цена машины зависит от модели и фирмы. Скидка зависит от фирмы, то есть
зависимость от первичного ключа неполная. Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят от
ПК.

| Модель | Фирма  | Цена  |
|--------|--------|-------|
| M5     | BMW    | 123   |
| X5M    | BMW    | 3213  |
| M1     | BMW    | 12312 |
| GT-R   | Nissan | 12323 |

| Фирма  | Скидка |
|--------|--------|
| BMW    | 5%     |
| Nissan | 10%    |

#### Третья нормальная форма

Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря,
второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

| Модель | Магазин    | Телефон  |
|--------|------------|----------|
| BMW    | Риал-авто  | 87-33-98 |
| Audi   | Риал-авто  | 87-33-98 |
| Nissan | Некст-Авто | 94-54-12 |

аблица находится во 2НФ, но не в 3НФ.

В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина.

Таким образом, в отношении существуют следующие функциональные зависимости: Модель → Магазин, Магазин → Телефон, Модель → Телефон.

Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.

В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:

| Модель | Магазин    |
|--------|------------|
| BMW    | Риал-авто  |
| Audi   | Риал-авто  |
| Nissan | Некст-Авто |

| Магазин    | Телефон  |
|------------|----------|
| Риал-авто  | 87-33-98 |
| Риал-авто  | 87-33-98 |
| Некст-Авто | 94-54-12 |


### Основные классы баз данных

https://proselyte.net/db-types-for-devs/
Современные СУБД разнообразны, но их можно разделить на несколько основных классов по характеру нагрузок и модели данных:

- **OLTP** (OnLine Transaction Processing) – это системы управления базами данных, оптимизированные для обработки большого числа коротких транзакций в реальном времени. Пример _Oracle, PostgreSQL, MySQL, Microsoft SQL Server_
- **OLAP** (OnLine Analytical Processing) – системы онлайн-аналитики. Предназначены для агрегирования и анализа больших объёмов данных, выполнения сложных запросов. **Ориентирован на чтение и анализ данных**, часто исторических, с различных разрезов. Часто используют колонковое хранение данных и масштабирование на кластере. Пример: _Apache ClickHouse, Greenplum, Apache Hive (поверх Hadoop), Microsoft Analysis Services, Apache Druid._
- **HTAP** (Hybrid Transaction/Analytical Processing) – гибридный подход, сочетающий возможности OLTP и OLAP в одной системе. Идея HTAP заключается в том, чтобы одна и та же база данных могла эффективно обслуживать и быстрые транзакции, и тяжёлые аналитические запросы одновременно. HTAP-системы проектируются, чтобы **избежать разрыва** между OLTP и OLAP, позволяя выполнять аналитику на «живых» данных без выгрузки. Пример: _SAP HANA, MemSQL (SingleStore), Oracle Autonomous Database, Microsoft HTAP, TiDB._
- **NoSQL** базы данных – нереляционные хранилища, включающие несколько подтипов:
    - **Key-Value**. **Недостатки** KV-хранилищ: Отсутствие сложных запросов и транзакций  Примеры: _Redis, Memcached, Riak, Amazon DynamoDB_
    - **Document-oriented** Документные базы хорошо подходят, когда данные по природе слабо структурированы. Пример: _MongoDB_ (хранит документы BSON (бинарный JSON), имеет богатый язык запросов), _CouchDB_ (хранит JSON, использует MapReduce для вычисления представлений (views)), _Couchbase_ (сочетает возможности key-value (как Memcached) и документа, имеет SQL-подобный язык N1QL)
    - **Column-family** это системы, где данные хранятся в строках, но разрезанных по колонкам. Каждая **строка** определяется ключом, а данные внутри неё хранятся не как фиксированный набор колонок, а как **семейства колонок** – группы пар «колонка-значение». Пример _Apache HBase, Apache Cassandra, ScyllaDB, Amazon Keyspaces_
    - **Graph**. Данные хранятся в виде **узлов** (вершин) и **рёбер** (грани, связывающие узлы), причём и узлы, и рёбра могут иметь произвольный набор свойств (ключ-значение). Графовые базы данных отлично подходят для рекомендаций. Если данных немного или связи не сложные, можно справиться и обычной БД. Пример: _Neo4j, Amazon Neptune, OrientDB, ArangoDB, Apache JanusGraph_
- **NewSQL** – новое поколение реляционных СУБД, сочетающих SQL и ACID-транзакции с масштабируемостью, присущей NoSQL. Проще говоря, NewSQL = «мы любим SQL, но хотим, чтобы база масштабировалась на кластер как NoSQL». **Где применять NewSQL**: Когда проект требует высокой транзакционной нагрузки и масштабирования, но отказаться от консистентности и SQL неудобно. Например, _финансовые приложения глобального масштаба_, _игровые бэкенды с миллионами одновременных игроков_ (где нужна и скорость, и сохранность данных)
    - Есть два подхода к NewSQL:
        - **Новые движки «с нуля»**, спроектированные специально, пример: _VoltDB, FoundationDB, CockroachDB, NuoDB_. 
        - **Модификация существующих СУБД**, чтобы придать им горизонтальный масштаб, пример: распределённые кластеры MySQL – _Galera, Vitess_; NewSQL-надстройки типа _YugabyteDB_ для PostgreSQL; улучшенные движки хранения MySQL как _TokuDB_).
    - Примеры NewSQL:
        - **Google Spanner** – пожалуй, первый яркий представитель: глобально распределённая SQL-база, гарантирующая консистентность (TrueTime, синхронизация по GPS/атомным часам). Доступна в Google Cloud как Cloud Spanner.
        - **CockroachDB** – open-source NewSQL, совместимая по интерфейсу с PostgreSQL. Масштабируется по принципу «как тараканы – выживает всё» ?: данные реплицируются с сильной консистентностью, можно переживать падения узлов; обеспечивает распределённые ACID-транзакции.
        - **VoltDB** – in-memory NewSQL, ориентированная на сверхнизкие задержки, ACID, горизонтальное масштабирование. Транзакции выполняются в памяти, синхронно реплицируются для надёжности.
        - **TiDB** – упомянутая ранее HTAP NewSQL (MySQL-совместимая), разбивает данные как у Google Spanner, транзакции распределённые.
        - **Amazon Aurora** – масштабируемый движок, совместимый с MySQL/PostgreSQL, в AWS. Хотя Aurora не полностью шардируется между серверами приложений (это скорее оптимизация под облако с разделением вычислений и хранения), AWS позиционирует её как modern SQL с лучше масштабируемостью.
        - **Microsoft Cosmos DB (SQL API)** – многомодельная БД, поддерживающая SQL-подобный язык запросов, глобальное масштабирование (но под капотом там не совсем реляционная, а скорее документо-колонковая, все же пример нового подхода).
- **Time-Series DB** – специализированный тип СУБД для хранения и обработки временных рядов, то есть последовательностей значений во времени. Временной ряд – это набор пар «метка времени – значение», например: температура датчика каждую минуту, курс акции по дням, загрузка CPU сервера каждую секунду. Хотя временные ряды можно хранить и в реляционной или NoSQL базе, TSDB оптимизированы специально под эти нагрузки.
    - Обычно это выражается в следующих чертах:
        - **Эффективная запись** большого числа метрик в реалтайме (в секунду могут поступать тысячи/миллионы точек от датчиков).
        - **Сжатие данных** и хранение с учётом временной корреляции (значения во времени часто коррелированы, можно сжимать дельты).
        - **Быстрая агрегация** по интервалам: TSDB имеют встроенные функции downsampling, aggregation по окнам (hourly, daily).
        - **Хранение только аппендиксом** (append-only): данные добавляются по времени, редко обновляются прошлые точки (обычно данные иммутабельны после записи).
        - **Retention / TTL механизм**: часто старые данные автоматически удаляются или агрегируются, чтобы ограничить объем.
    - Примеры TSDB:
        - **InfluxDB** – популярная открытая TSDB, язык запросов InfluxQL (SQL-подобный) или Flux, поддерживает теги (метаданные) для серий.
        - **Prometheus** – СУБД для метрик мониторинга, сбор данных через pull, имеет свой язык PromQL.
        - **Graphite** – более старое решение, хранит ряды файловой системой (или Whisper DB), часто используется для мониторинга.
        - **TimescaleDB** – надстройка над PostgreSQL (расширение), превращающее его в TSDB: оптимизирует хранение серий, предлагает удобный синтаксис для интервалов.
        - **OpenTSDB** – распределенная TSDB поверх HBase.
        - **VictoriaMetrics** – высокопроизводительная TSDB, часто используется как замена Prometheus для долгого хранения.
        - **KDB+** – колоночная БД, популярна в финтехе для временных рядов (например, рынки).
        - **В облаках**: _Amazon Timestream, Azure Time Series Insights, Google Cloud Monitoring (Stackdriver)_.
- **Vector DB** – векторные базы данных, хранящие высокоразмерные векторы для поиска по сходству (popularity в задачах ML/AI). Сейчас векторные БД – основа для семантического поиска (ищем документы не по ключевому слову, а по смыслу запроса)
- **In-Memory DB** – базы данных в оперативной памяти, хранящие все данные в ОЗУ для минимальных задержек.
- **Event Stores** – хранилища событий, ориентированные на запись и чтение потоков событий (например, для Event Sourcing). В некотором смысле, это похоже на журнал транзакций или лог в чистом виде. **Когда нужен Event Store**: В системах, использующих архитектуру на событиях. Пример: _Kafka, EventStoreDB, Azure Event Hub_
- **Search Engine DB** – поисковые движки (Elasticsearch, OpenSearch и др.), специализированные на полнотекстовом поиске и анализе неструктурированных данных.


