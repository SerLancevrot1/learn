# Базы данных

### Реляционные 

### Нереляционные/NoSql
Бывают:
- Ключ-значение
- Графовые
- Столбцовые
- Документные

Хороший выбор если:
- Нужна крайне низкая задержка (латентность)
- Данные не структурированы или не имеют связей
- Нужно всего лишь сериализовать/десериализовать данные (XML, JSON, YAML)
- Нужно хранить огромные объемы данных



### Индексы PostgreSQL
- **B-tree** - это самый распространенный тип индекса в PostgreSQL. Он поддерживает все стандартные операции сравнения (>, <, >=, <=, =, <>) и может использоваться с большинством типов данных. B-tree индексы могут быть использованы для сортировки, ограничений уникальности и поиска по диапазону значений.
- **Hash** - предназначены для обеспечения быстрого доступа к данным по **равенству**. Они менее эффективны, чем B-tree индексы, и **не поддерживают сортировку или поиск по диапазону значений**. Из-за своих ограничений, Hash-индексы редко используются на практике.
- **GiST (Generalized Search Tree)** - являются обобщенными и многоцелевыми, предназначены для работы с сложными типами данных, такими как **геометрические объекты, текст и массивы**. Они позволяют быстро выполнять поиск по **пространственным, текстовым и иерархическим данным**.
- **SP-GiST (Space-Partitioned Generalized Search Tree)** - предназначены для работы с непересекающимися и неравномерно распределенными данными. Они эффективны для поиска в **геометрических и IP-адресных данных**.
- **GIN (Generalized Inverted Index)** - применяются для **полнотекстового поиска** и поиска по **массивам, JSON и триграммам**. Они обеспечивают высокую производительность при поиске в больших объемах данных.
- **BRIN (Block Range INdex)** - используются для компактного представления больших объемов данных, особенно когда значения в таблице имеют определенный порядок. Они эффективны для хранения и обработки временных рядов и географических данных.
- 


### N + 1
- **FetchType.LAZY** `@ManyToOne(fetch = FetchType.LAZY)`
- **EntityGraph** вы можете заранее указать, какие объекты нужно загрузить вместе с основным объектом.
- **JOIN FETCH** Этот оператор объединяет основную таблицу и связанные таблицы в одном SQL-запросе, что позволяет загрузить данные сразу за один раз. Таким образом, JOIN FETCH позволяет эффективно загружать связанные объекты одновременно с основными объектами, уменьшая количество обращений к базе данных.


### Блокировки
- Оптимистические - использует версии. Работает по принципу CAS (Compare And Swap): сравнил и, если версия больше, заменил.
- Пессимистические - классическая полная блокировка

### ACID

В информатике акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и
предсказуемую её работу.

#### Atomicity — Атомарность

Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не
выполнено ни одной.

#### Consistency — Согласованность

Каждая успешная транзакция по определению фиксирует только допустимые результаты.

#### Isolation — Изолированность

Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Изолированность — требование дорогое,
поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию

#### Durability — Долговечность

Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут
отменены из-за какого-либо сбоя.

### Проблемы параллельного доступа с использованием транзакций

**Потерянное обновление (англ. lost update)** — при одновременном изменении одного блока данных разными транзакциями одно из изменений
теряется;

| Транзакция 1                           | Транзакция 2                           |
|----------------------------------------|----------------------------------------|
| `UPDATE tbl1 SET f2=f2+20 WHERE f1=1;` | `UPDATE tbl1 SET f2=f2+25 WHERE f1=1;` |

**Грязное чтение (англ. dirty read)** — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (
откатится);

| Транзакция 1                          | Транзакция 2                      |
|---------------------------------------|-----------------------------------|
| `UPDATE tbl1 SET f2=f2+1 WHERE f1=1;` |                                   |
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |
| `ROLLBACK WORK;`                      |                                   |

**Неповторяющееся чтение (англ. non-repeatable read)** — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются
изменёнными;

| Транзакция 1                          | Транзакция 2                      |
|---------------------------------------|-----------------------------------|
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |
| `UPDATE tbl1 SET f2=f2+1 WHERE f1=1;` |                                   |
| `COMMIT;`                             |                                   |
|                                       | `SELECT f2 FROM tbl1 WHERE f1=1;` |

**Фантомное чтение (англ. phantom reads)** — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем
же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки, или изменяет столбцы некоторых строк,
используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой
транзакции дают разные множества строк.

| Транзакция 1                               | Транзакция 2                |
|--------------------------------------------|-----------------------------|
|                                            | `SELECT SUM(f2) FROM tbl1;` |
| `INSERT INTO tbl1 (f1,f2) VALUES (15,20);` |                             |
| `COMMIT;`                                  |                             |
|                                            | `SELECT SUM(f2) FROM tbl1;` |

### Уровень изолированности транзакций

**Уровень изолированности транзакций** — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.

Стандарт SQL-92 определяет шкалу из четырёх уровней изоляции: Read uncommitted, Read committed, Repeatable read, Serializable.
- Read uncommitted - позволяет читать данные которые не были закомиченны. Нет гарантии что данные не изменятся
- Read committed - позволяет читать только закомиченные данные
- Repeatable read - позволяет чтение и запись пока другая транзакция активна. Но если транзакция понимает что данные изменились, но она не будет коммитится
- Serializable - полностью блокирует сроки пока транзакция не закончится




### Нормальные формы

**Нормальная форма** — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных
функциональных зависимостей между атрибутами (полями таблиц).

#### Первая нормальная форма

Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не
должно быть повторений строк в таблице.

Например, есть таблица «Автомобили»:

| Фирма  | Модели      |
|--------|-------------|
| BMW    | M5, X5M, M1 |
| Nissan | GT-R        |

Нарушение нормализации 1НФ происходит в моделях BMW, т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, т.е. он не является
атомарным. Преобразуем таблицу к 1НФ:

| Фирма  | Модели |
|--------|--------|
| BMW    | M5     |
| BMW    | X5M    |
| BMW    | M1     |
| Nissan | GT-R   |

#### Вторая нормальная форма

Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут зависит от Первичного Ключа(ПК).

| Модель | Фирма  | Цена  | Скидка |
|--------|--------|-------|--------|
| M5     | BMW    | 123   | 5%     |
| X5M    | BMW    | 3213  | 5%     |
| M1     | BMW    | 12312 | 5%     |
| GT-R   | Nissan | 12323 | 10%    |

Таблица находится в первой нормальной форме, но не во второй. Цена машины зависит от модели и фирмы. Скидка зависит от фирмы, то есть
зависимость от первичного ключа неполная. Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят от
ПК.

| Модель | Фирма  | Цена  |
|--------|--------|-------|
| M5     | BMW    | 123   |
| X5M    | BMW    | 3213  |
| M1     | BMW    | 12312 |
| GT-R   | Nissan | 12323 |

| Фирма  | Скидка |
|--------|--------|
| BMW    | 5%     |
| Nissan | 10%    |

#### Третья нормальная форма

Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря,
второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.

| Модель | Магазин    | Телефон  |
|--------|------------|----------|
| BMW    | Риал-авто  | 87-33-98 |
| Audi   | Риал-авто  | 87-33-98 |
| Nissan | Некст-Авто | 94-54-12 |

аблица находится во 2НФ, но не в 3НФ.

В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина.

Таким образом, в отношении существуют следующие функциональные зависимости: Модель → Магазин, Магазин → Телефон, Модель → Телефон.

Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.

В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:

| Модель | Магазин    |
|--------|------------|
| BMW    | Риал-авто  |
| Audi   | Риал-авто  |
| Nissan | Некст-Авто |

| Магазин    | Телефон  |
|------------|----------|
| Риал-авто  | 87-33-98 |
| Риал-авто  | 87-33-98 |
| Некст-Авто | 94-54-12 |
